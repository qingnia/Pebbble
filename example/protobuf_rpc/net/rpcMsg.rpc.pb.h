// Generated by the Pebble C++ plugin 1.0.1.0 01:22:18 Nov  5 2018
// If you make any local change, they will be lost.
// source: example/protobuf_rpc/net/rpcMsg.proto
#ifndef _PEBBLE_example_2fprotobuf_5frpc_2fnet_2frpcMsg_2eproto_H_
#define _PEBBLE_example_2fprotobuf_5frpc_2fnet_2frpcMsg_2eproto_H_


#include "rpcMsg.rpc.pb.inh"


namespace example {

/*  ������� */
/*  ��ʱֻ�ṩ�ӷ����� */
class rpcMsgClient : public rpcMsgClientInterface {
public:
    /* IDL定义接口，每个接口对应生成3个方法，分别是同步调用、并行调用、异步调用 */

    /*  �ӷ����� */
    /*  �������������ĺ� */
    /* add同步调用，返回0时调用成功，非0失败 */
    virtual int32_t add(const ::example::CalRequest& request, ::example::CalResponse* response);
    /* add并行调用，一般通过Pebble并行模块(pebble::AddCall/WhenAll)来使用此接口 */
    virtual int32_t Paralleladd(const ::example::CalRequest& request, int32_t* ret_code, ::example::CalResponse* response, uint32_t* num_called, uint32_t* num_parallel);
    /* add异步调用，回调函数第一个参数为RPC调用结果，0为成功，非0失败 */
    virtual void add(const ::example::CalRequest& request, const cxx::function<void(int32_t ret_code, const ::example::CalResponse& response)>& cb);
    /* login同步调用，返回0时调用成功，非0失败 */
    virtual int32_t login(const ::example::LoginInfo& request, ::example::playersInfo* response);
    /* login并行调用，一般通过Pebble并行模块(pebble::AddCall/WhenAll)来使用此接口 */
    virtual int32_t Parallellogin(const ::example::LoginInfo& request, int32_t* ret_code, ::example::playersInfo* response, uint32_t* num_called, uint32_t* num_parallel);
    /* login异步调用，回调函数第一个参数为RPC调用结果，0为成功，非0失败 */
    virtual void login(const ::example::LoginInfo& request, const cxx::function<void(int32_t ret_code, const ::example::playersInfo& response)>& cb);
    /* modifyStatus同步调用，返回0时调用成功，非0失败 */
    virtual int32_t modifyStatus(const ::example::StatusReceive& request, ::example::commonResponse* response);
    /* modifyStatus并行调用，一般通过Pebble并行模块(pebble::AddCall/WhenAll)来使用此接口 */
    virtual int32_t ParallelmodifyStatus(const ::example::StatusReceive& request, int32_t* ret_code, ::example::commonResponse* response, uint32_t* num_called, uint32_t* num_parallel);
    /* modifyStatus异步调用，回调函数第一个参数为RPC调用结果，0为成功，非0失败 */
    virtual void modifyStatus(const ::example::StatusReceive& request, const cxx::function<void(int32_t ret_code, const ::example::commonResponse& response)>& cb);
    /* move同步调用，返回0时调用成功，非0失败 */
    virtual int32_t move(const ::example::moveRequest& request, ::example::commonResponse* response);
    /* move并行调用，一般通过Pebble并行模块(pebble::AddCall/WhenAll)来使用此接口 */
    virtual int32_t Parallelmove(const ::example::moveRequest& request, int32_t* ret_code, ::example::commonResponse* response, uint32_t* num_called, uint32_t* num_parallel);
    /* move异步调用，回调函数第一个参数为RPC调用结果，0为成功，非0失败 */
    virtual void move(const ::example::moveRequest& request, const cxx::function<void(int32_t ret_code, const ::example::commonResponse& response)>& cb);
    /* chat同步调用，返回0时调用成功，非0失败 */
    virtual int32_t chat(const ::example::chatReceive& request, ::example::commonResponse* response);
    /* chat并行调用，一般通过Pebble并行模块(pebble::AddCall/WhenAll)来使用此接口 */
    virtual int32_t Parallelchat(const ::example::chatReceive& request, int32_t* ret_code, ::example::commonResponse* response, uint32_t* num_called, uint32_t* num_parallel);
    /* chat异步调用，回调函数第一个参数为RPC调用结果，0为成功，非0失败 */
    virtual void chat(const ::example::chatReceive& request, const cxx::function<void(int32_t ret_code, const ::example::commonResponse& response)>& cb);

public:
    /* 功能接口 */

    rpcMsgClient(::pebble::PebbleRpc* rpc);
    virtual ~rpcMsgClient();

    /* 设置连接句柄，RPC请求通过此句柄对应的连接发送 */
    void SetHandle(int64_t handle);

    /* 设置路由函数，连接的选择交给路由回调函数处理，RPC请求通过路由回调函数选择的连接发送 */
    /* 设置路由回调函数后，不再使用SetHandle设置的连接句柄 */
    void SetRouteFunction(const cxx::function<int64_t(uint64_t key)>& route_callback);

    /* 设置路由key，如使用取模或哈希路由策略时使用 */
    void SetRouteKey(uint64_t route_key);

    /* 设置广播的频道名字，设置了频道后Client将所有的RPC请求按广播处理，广播至channel_name */
    void SetBroadcast(const std::string& channel_name);

    /* 设置RPC请求超时时间(单位ms)，未指定方法名时对所有方法生效，指定方法名时只对指定方法生效，默认的超时时间为10s */
    int SetTimeout(uint32_t timeout_ms, const char* method_name = NULL);


private:
    rpcMsgClientImp* m_imp;
};

/*  ������� */
/*  ��ʱֻ�ṩ�ӷ����� */
class rpcMsgServerInterface {
public:
    virtual ~rpcMsgServerInterface() {}

    /*  �ӷ����� */
    /*  �������������ĺ� */
    virtual void add(const ::example::CalRequest& request, cxx::function<void(int32_t ret_code, const ::example::CalResponse& response)>& rsp) = 0;
    virtual void login(const ::example::LoginInfo& request, cxx::function<void(int32_t ret_code, const ::example::playersInfo& response)>& rsp) = 0;
    virtual void modifyStatus(const ::example::StatusReceive& request, cxx::function<void(int32_t ret_code, const ::example::commonResponse& response)>& rsp) = 0;
    virtual void move(const ::example::moveRequest& request, cxx::function<void(int32_t ret_code, const ::example::commonResponse& response)>& rsp) = 0;
    virtual void chat(const ::example::chatReceive& request, cxx::function<void(int32_t ret_code, const ::example::commonResponse& response)>& rsp) = 0;


    typedef rpcMsgServerInterface __InterfaceType;
};


} // namespace example

/* 内部使用，用户无需关注 */
namespace pebble {
template<typename Class> class GenServiceHandler;

template<>
class GenServiceHandler< ::example::rpcMsgServerInterface> {
public:
    cxx::shared_ptr< ::pebble::IPebbleRpcService> operator() (::pebble::PebbleRpc* rpc, ::example::rpcMsgServerInterface *iface) {
        cxx::shared_ptr< ::pebble::IPebbleRpcService> service_handler(
            new ::example::__rpcMsgSkeleton(rpc, iface));
        return service_handler;
    }
};
} // namespace pebble



#endif // _PEBBLE_example_2fprotobuf_5frpc_2fnet_2frpcMsg_2eproto_HH_
